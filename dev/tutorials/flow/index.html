<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Flow Inversion · FwiFlow</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="FwiFlow logo"/></a><div class="docs-package-name"><span class="docs-autofit">FwiFlow</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Getting Started</a></li><li><a class="tocitem" href="../../api/">API Reference</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../fwi/">FWI</a></li><li class="is-active"><a class="tocitem" href>Flow Inversion</a></li><li><a class="tocitem" href="../timefrac/">Time Fractional Differential Equation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorial</a></li><li class="is-active"><a href>Flow Inversion</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Flow Inversion</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lidongzh/FwiFlow.jl/blob/master/docs/src/tutorials/flow.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Flow-Inversion-1"><a class="docs-heading-anchor" href="#Flow-Inversion-1">Flow Inversion</a><a class="docs-heading-anchor-permalink" href="#Flow-Inversion-1" title="Permalink"></a></h1><p>This section is an example of solving the flow equation with the Newton-Raphson method. The governing equations are derived from conservation of mass of each phase, and conservation of momentum or Darcy&#39;s law for each phase. First, we have</p><div>\[\frac{\partial }{{\partial t}}(\phi {S_i}{\rho _i}) + \nabla  \cdot ({\rho _i}{\mathbf{v}_i}) = {\rho _i}{q_i}, \quad i = 1,2 \tag{1}\]</div><p>The saturation of the two phases satisfies</p><div>\[S_{1} + S_{2} = 1\tag{2}\]</div><p>and the Darcy&#39;s law yields</p><div>\[{\mathbf{v}_i} =  - \frac{{K{k_{ri}(S_i)}}}{{{\tilde{\mu}_i}}}(\nabla {P_i} - g{\rho _i}\nabla Z), \quad i=1,2 \tag{3}\]</div><p>Here, <span>$K$</span> is the permeability tensor, but in our case we assume it is a space varying scalar value. <span>$k_{ri}(S_i)$</span> is a function of <span>$S_i$</span>, and typically the higher the saturation, the easier the corresponding phase is to flow. <span>$\tilde \mu_i$</span> is the viscosity <sup class="footnote-reference"><a id="citeref-pcl" href="#footnote-pcl">[pcl]</a></sup>. <span>$Z$</span> is the depth cordinate, <span>$\rho_i$</span> is the density, <span>$\phi$</span> is the porosity, <span>$q_i$</span> is the source, <span>$P_i$</span> is the fluid pressure and <span>$g$</span> is the velocity constant. </p><p>The fluid pressure <span>$P_i$</span> is related to <span>$S_i$</span> via the capillary pressure </p><div>\[P_2 = P_1 - P_c(S_2)\tag{4}\]</div><p>where <span>$P_c$</span> is a function of the saturation of the wetting phase 2. </p><p>In Equations 1-4, the state variables are <span>$S_1$</span>, <span>$S_2$</span>, <span>$\mathbf{v}_i$</span>, <span>$P_1$</span>, and <span>$P_2$</span>. There are 6 equations and 6 variables (taking dimension into consideration) in total, and thus the system is complete. </p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>In all the numerical scheme below, we adopt the finite volumn method. Each cell in the following discretized domain is a cell and the state variables <span>$\Psi_2, S_1, S_2$</span> and the capillary potential <span>$\Psi_c$</span> are defined per cell. <img src="../../assets/doc_domain.png" alt/></p></div></div><p><strong>Step 1: Parameters Setup</strong></p><pre><code class="language-julia">const K_CONST =  9.869232667160130e-16 * 86400 * 1e3
const ALPHA = 1.0
mutable struct Ctx
  m; n; h; NT; Δt; Z; X; ρw; ρo;
  μw; μo; K; g; ϕ; qw; qo; sw0
end

function tfCtxGen(m,n,h,NT,Δt,Z,X,ρw,ρo,μw,μo,K,g,ϕ,qw,qo,sw0,ifTrue)
  tf_h = constant(h)
  # tf_NT = constant(NT)
  tf_Δt = constant(Δt)
  tf_Z = constant(Z)
  tf_X= constant(X)
  tf_ρw = constant(ρw)
  tf_ρo = constant(ρo)
  tf_μw = constant(μw)
  tf_μo = constant(μo)
  # tf_K = isa(K,Array) ? Variable(K) : K
  if ifTrue
    tf_K = constant(K)
  else
    tf_K = Variable(K)
  end
  tf_g = constant(g)
  # tf_ϕ = Variable(ϕ)
  tf_ϕ = constant(ϕ)
  tf_qw = constant(qw)
  tf_qo = constant(qo)
  tf_sw0 = constant(sw0)
  return Ctx(m,n,tf_h,NT,tf_Δt,tf_Z,tf_X,tf_ρw,tf_ρo,tf_μw,tf_μo,tf_K,tf_g,tf_ϕ,tf_qw,tf_qo,tf_sw0)
end

function Krw(Sw)
    return Sw ^ 1.5
end

function Kro(So)
    return So ^1.5
end

function ave_normal(quantity, m, n)
    aa = sum(quantity)
    return aa/(m*n)
end</code></pre><p><strong>Step 2: Implementing the Numerical Scheme</strong></p><p>The major simulation codes consist of using a nonlinear implicit timestep for (1), </p><div>\[\phi (S_2^{n + 1} - S_2^n) - \nabla \cdot \left( {{m_{2}}(S_2^{n + 1})K\nabla \Psi _2^n} \right) \Delta t = 
\left(q_2^n + q_1^n \frac{m_2(S^{n+1}_2)}{m_1(S^{n+1}_2)}\right) 
\Delta t \tag{5}\]</div><p>Here <span>$m_i(s) = \frac{k_{ri}(s)}{\tilde \mu_i}$</span> and <span>$\Psi_i = P_i - \rho_i g Z$</span>. </p><p>In <a href="../../api/#FwiFlow.sat_op"><code>sat_op</code></a> we solve the nonlinear equation (5) with a Newton-Raphson scheme. </p><pre><code class="language-julia"># variables : sw, u, v, p
# (time dependent) parameters: qw, qo, ϕ
function onestep(sw, p, m, n, h, Δt, Z, ρw, ρo, μw, μo, K, g, ϕ, qw, qo)
    # step 1: update p
    # λw = Krw(sw)/μw
    # λo = Kro(1-sw)/μo
    λw = sw.*sw/μw
    λo = (1-sw).*(1-sw)/μo
    λ = λw + λo
    q = qw + qo + λw/(λo+1e-16).*qo
    # q = qw + qo
    potential_c = (ρw - ρo)*g .* Z

    # Step 1: implicit potential
    Θ = upwlap_op(K * K_CONST, λo, potential_c, h, constant(0.0))

    load_normal = (Θ+q/ALPHA) - ave_normal(Θ+q/ALPHA, m, n)

    # p = poisson_op(λ.*K* K_CONST, load_normal, h, constant(0.0), constant(1))
    p = upwps_op(K * K_CONST, λ, load_normal, p, h, constant(0.0), constant(0)) # potential p = pw - ρw*g*h 

    # step 2: implicit transport
    sw = sat_op(sw, p, K * K_CONST, ϕ, qw, qo, μw, μo, sw, Δt, h)
    return sw, p
end


function imseq(tf_ctx)
    ta_sw, ta_p = TensorArray(NT+1), TensorArray(NT+1)
    ta_sw = write(ta_sw, 1, tf_ctx.sw0)
    ta_p = write(ta_p, 1, constant(zeros(tf_ctx.m, tf_ctx.n)))
    i = constant(1, dtype=Int32)
    function condition(i, tas...)
        i &lt;= tf_ctx.NT
    end
    function body(i, tas...)
        ta_sw, ta_p = tas
        sw, p = onestep(read(ta_sw, i), read(ta_p, i), tf_ctx.m, tf_ctx.n, tf_ctx.h, tf_ctx.Δt, tf_ctx.Z, tf_ctx.ρw, tf_ctx.ρo, tf_ctx.μw, tf_ctx.μo, tf_ctx.K, tf_ctx.g, tf_ctx.ϕ, tf_ctx.qw[i], tf_ctx.qo[i])
        ta_sw = write(ta_sw, i+1, sw)
        ta_p = write(ta_p, i+1, p)
        i+1, ta_sw, ta_p
    end

    _, ta_sw, ta_p = while_loop(condition, body, [i, ta_sw, ta_p])
    out_sw, out_p = stack(ta_sw), stack(ta_p)
end</code></pre><p><strong>Step 3: Forward Computation</strong></p><p>We now first generate the synthetic data. </p><pre><code class="language-julia">using FwiFlow
using PyCall
using LinearAlgebra
using DelimitedFiles
np = pyimport(&quot;numpy&quot;)

const SRC_CONST = 86400.0 #
const GRAV_CONST = 9.8    # gravity constant

# Hyperparameter for flow simulation
m = 15
n = 30
h = 30.0 # meter
NT  = 50
dt_survey = 5
Δt = 20.0 # day
z = (1:m)*h|&gt;collect
x = (1:n)*h|&gt;collect
X, Z = np.meshgrid(x, z)

ρw = 501.9
ρo = 1053.0
μw = 0.1
μo = 1.0

K_init = 20.0 .* ones(m,n) # initial guess of permeability 

g = GRAV_CONST
ϕ = 0.25 .* ones(m,n)
qw = zeros(NT, m, n)
qw[:,9,3] .= 0.005 * (1/h^2)/10.0 * SRC_CONST
qo = zeros(NT, m, n)
qo[:,9,28] .= -0.005 * (1/h^2)/10.0 * SRC_CONST
sw0 = zeros(m, n)
survey_indices = collect(1:dt_survey:NT+1) # 10 stages
n_survey = length(survey_indices)



K = 20.0 .* ones(m,n) # millidarcy
K[8:10,:] .= 120.0
tfCtxTrue = tfCtxGen(m,n,h,NT,Δt,Z,X,ρw,ρo,μw,μo,K,g,ϕ,qw,qo, sw0, true)
out_sw_true, out_p_true = imseq(tfCtxTrue)</code></pre><p><img src="../../assets/sw10.png" alt/></p><p><strong>Step 4: Inversion</strong></p><p>We now conduct inversion. The unknown variable is stored in <code>tfCtxInit.K</code>. </p><pre><code class="language-julia">tfCtxInit = tfCtxGen(m,n,h,NT,Δt,Z,X,ρw,ρo,μw,μo,K_init,g,ϕ,qw,qo, sw0, false)
out_sw_init, out_p_init = imseq(tfCtxInit)

sess = Session(); init(sess)
O = run(sess, out_sw_init)
vis(O)
# NOTE Compute FWI loss


loss = sum((out_sw_true-out_sw_init)^2)
opt = ScipyOptimizerInterface(loss, options=Dict(&quot;maxiter&quot;=&gt; 100, &quot;ftol&quot;=&gt;1e-12, &quot;gtol&quot;=&gt;1e-12),var_to_bounds = Dict(tfCtxInit.K=&gt;(10.0, 130.0)))
       

__cnt = 0
__loss = 0
out = []
function print_loss(l)
    if mod(__cnt,1)==0
        println(&quot;iter $__cnt, current loss=&quot;,l)
    end
    global __loss = l
    global __cnt += 1
end
__iter = 0
function step_callback(rk)
    if mod(__iter,1)==0
        println(&quot;================ ITER $__iter ===============&quot;)
    end
    println(&quot;$__loss&quot;)
    push!(out, __loss)
    global __iter += 1
end
sess = Session(); init(sess)
ScipyOptimizerMinimize(sess, opt, loss_callback=print_loss, 
        step_callback=step_callback, fetches=[loss])</code></pre><p><img src="../../assets/coupled_loss.png" alt/></p><p>We can visualize <code>K</code> with </p><pre><code class="language-julia">imshow(run(sess, tfCtxInit.K), extent=[0,n*h,m*h,0]);
xlabel(&quot;Distance (m)&quot;)
ylabel(&quot;Depth (m)&quot;)
cb = colorbar()
clim([20, 120])
cb.set_label(&quot;Permeability (md)&quot;)</code></pre><p><img src="../../assets/Saturation_evo_patchy_init.png" alt/> <img src="../../assets/Saturation_evo_patchy_true.png" alt/></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-pcl"><a class="tag is-link" href="#citeref-pcl">pcl</a><a href="https://arxiv.org/abs/2002.10521">This paper</a> gives a description of common relative permeability models and proposes a method to calibrate an empirical model from indirect data. </li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fwi/">« FWI</a><a class="docs-footer-nextpage" href="../timefrac/">Time Fractional Differential Equation »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 17 March 2020 06:41">Tuesday 17 March 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
